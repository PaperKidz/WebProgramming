<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Scene</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 5px;
            font-size: 13px;
            max-width: 320px;
        }
        .highlight {
            color: #4ecdc4;
            font-weight: bold;
        }
        .key {
            color: #ffd700;
            font-weight: bold;
        }
        #selectedInfo {
            margin-top: 10px;
            padding: 8px;
            background: rgba(78, 205, 196, 0.2);
            border-radius: 3px;
            display: none;
        }
    </style>
</head>
<body>
    <div id="info">
        <strong>Interactive Controls</strong><br><br>
        <span class="highlight">Mouse Click:</span><br>
        • Click on any object to select it<br>
        • Selected object changes color<br><br>
        <span class="highlight">Keyboard (WASD + QE):</span><br>
        • <span class="key">W/S</span>: Move forward/backward<br>
        • <span class="key">A/D</span>: Move left/right<br>
        • <span class="key">Q/E</span>: Move up/down<br>
        • Controls the <span class="key">RED CUBE</span><br><br>
        <span class="highlight">Camera:</span><br>
        • Right Mouse: Rotate | Scroll: Zoom<br>
        <div id="selectedInfo">
            <strong>Selected:</strong> <span id="selectedName">None</span>
        </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a1a);

        // Camera setup
        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 8, 15);
        camera.lookAt(0, 0, 0);

        // Renderer setup
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 10, 5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // Ground plane
        const planeGeometry = new THREE.PlaneGeometry(30, 30);
        const planeMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x1a1a2e,
            roughness: 0.8
        });
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotation.x = -Math.PI / 2;
        plane.receiveShadow = true;
        scene.add(plane);

        // Create interactive objects
        const objects = [];
        const originalColors = {};

        // Controllable Cube (Red) - WASD controls
        const cubeGeometry = new THREE.BoxGeometry(2, 2, 2);
        const cubeMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xff6b6b,
            metalness: 0.3,
            roughness: 0.5
        });
        const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
        cube.position.set(0, 1, 0);
        cube.castShadow = true;
        cube.name = "Controllable Cube";
        scene.add(cube);
        objects.push(cube);
        originalColors[cube.uuid] = 0xff6b6b;

        // Sphere (Blue)
        const sphereGeometry = new THREE.SphereGeometry(1.5, 32, 32);
        const sphereMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x4169e1,
            metalness: 0.4,
            roughness: 0.3
        });
        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
        sphere.position.set(-5, 1.5, -3);
        sphere.castShadow = true;
        sphere.name = "Blue Sphere";
        scene.add(sphere);
        objects.push(sphere);
        originalColors[sphere.uuid] = 0x4169e1;

        // Cylinder (Green)
        const cylinderGeometry = new THREE.CylinderGeometry(1, 1, 3, 32);
        const cylinderMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x2ecc71,
            metalness: 0.5,
            roughness: 0.4
        });
        const cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
        cylinder.position.set(5, 1.5, -3);
        cylinder.castShadow = true;
        cylinder.name = "Green Cylinder";
        scene.add(cylinder);
        objects.push(cylinder);
        originalColors[cylinder.uuid] = 0x2ecc71;

        // Torus (Purple)
        const torusGeometry = new THREE.TorusGeometry(1.2, 0.5, 16, 100);
        const torusMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x9b59b6,
            metalness: 0.6,
            roughness: 0.2
        });
        const torus = new THREE.Mesh(torusGeometry, torusMaterial);
        torus.position.set(-5, 1.2, 3);
        torus.castShadow = true;
        torus.name = "Purple Torus";
        scene.add(torus);
        objects.push(torus);
        originalColors[torus.uuid] = 0x9b59b6;

        // Cone (Yellow)
        const coneGeometry = new THREE.ConeGeometry(1.2, 2.5, 32);
        const coneMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xf39c12,
            metalness: 0.3,
            roughness: 0.5
        });
        const cone = new THREE.Mesh(coneGeometry, coneMaterial);
        cone.position.set(5, 1.25, 3);
        cone.castShadow = true;
        cone.name = "Yellow Cone";
        scene.add(cone);
        objects.push(cone);
        originalColors[cone.uuid] = 0xf39c12;

        // Raycaster for mouse picking
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let selectedObject = null;

        // Mouse click event for raycasting
        renderer.domElement.addEventListener('click', (event) => {
            // Skip if right mouse button
            if (event.button !== 0) return;

            // Calculate mouse position in normalized device coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Update raycaster
            raycaster.setFromCamera(mouse, camera);

            // Check for intersections
            const intersects = raycaster.intersectObjects(objects);

            // Reset previous selection
            if (selectedObject) {
                selectedObject.material.color.setHex(originalColors[selectedObject.uuid]);
                selectedObject.material.emissive.setHex(0x000000);
            }

            // Select new object
            if (intersects.length > 0) {
                selectedObject = intersects[0].object;
                selectedObject.material.color.setHex(0xffffff);
                selectedObject.material.emissive.setHex(0x4ecdc4);
                selectedObject.material.emissiveIntensity = 0.5;
                
                // Update UI
                document.getElementById('selectedInfo').style.display = 'block';
                document.getElementById('selectedName').textContent = selectedObject.name;
            } else {
                selectedObject = null;
                document.getElementById('selectedInfo').style.display = 'none';
            }
        });

        // Keyboard controls for cube movement
        const keys = {};
        const moveSpeed = 0.15;

        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        function updateCubeMovement() {
            if (keys['w']) cube.position.z -= moveSpeed;
            if (keys['s']) cube.position.z += moveSpeed;
            if (keys['a']) cube.position.x -= moveSpeed;
            if (keys['d']) cube.position.x += moveSpeed;
            if (keys['q']) cube.position.y -= moveSpeed;
            if (keys['e']) cube.position.y += moveSpeed;

            // Keep cube above ground
            cube.position.y = Math.max(1, cube.position.y);
        }

        // Camera controls
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let cameraDistance = Math.sqrt(
            camera.position.x ** 2 + 
            camera.position.y ** 2 + 
            camera.position.z ** 2
        );
        let cameraAngleX = Math.atan2(camera.position.z, camera.position.x);
        let cameraAngleY = Math.asin(camera.position.y / cameraDistance);
        const lookAtPoint = new THREE.Vector3(0, 2, 0);

        renderer.domElement.addEventListener('mousedown', (e) => {
            if (e.button === 2) {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            }
        });

        renderer.domElement.addEventListener('mouseup', () => {
            isDragging = false;
        });

        renderer.domElement.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;

                cameraAngleX -= deltaX * 0.01;
                cameraAngleY += deltaY * 0.01;
                cameraAngleY = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, cameraAngleY));

                updateCameraPosition();
                previousMousePosition = { x: e.clientX, y: e.clientY };
            }
        });

        renderer.domElement.addEventListener('wheel', (e) => {
            e.preventDefault();
            cameraDistance += e.deltaY * 0.01;
            cameraDistance = Math.max(5, Math.min(30, cameraDistance));
            updateCameraPosition();
        });

        renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());

        function updateCameraPosition() {
            camera.position.x = lookAtPoint.x + cameraDistance * Math.cos(cameraAngleY) * Math.cos(cameraAngleX);
            camera.position.y = lookAtPoint.y + cameraDistance * Math.sin(cameraAngleY);
            camera.position.z = lookAtPoint.z + cameraDistance * Math.cos(cameraAngleY) * Math.sin(cameraAngleX);
            camera.lookAt(lookAtPoint);
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Update cube movement
            updateCubeMovement();

            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>