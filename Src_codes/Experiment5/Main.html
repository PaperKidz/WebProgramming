<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Physics Simulation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 5px;
            font-size: 13px;
            max-width: 300px;
        }
        .highlight {
            color: #4ecdc4;
            font-weight: bold;
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 5px;
            color: white;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            font-size: 14px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            width: 100%;
        }
        button:hover {
            background: #764ba2;
        }
        .slider-container {
            margin: 10px 0;
        }
        input[type="range"] {
            width: 100%;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="info">
        <strong>‚öõÔ∏è Physics Simulation</strong><br><br>
        <span class="highlight">Features:</span><br>
        ‚Ä¢ Gravity simulation<br>
        ‚Ä¢ Bouncing with restitution<br>
        ‚Ä¢ Friction & air resistance<br>
        ‚Ä¢ Multiple object types<br>
        ‚Ä¢ Wall collisions<br><br>
        <span class="highlight">Controls:</span><br>
        ‚Ä¢ Right Mouse: Rotate view<br>
        ‚Ä¢ Scroll: Zoom<br>
        ‚Ä¢ Use panel to spawn objects
    </div>

    <div id="controls">
        <strong>üéÆ Spawn Objects</strong><br><br>
        <button onclick="spawnBall()">Drop Ball</button>
        <button onclick="spawnCube()">Drop Cube</button>
        <button onclick="spawnMultiple()">Drop 5 Objects</button>
        <button onclick="clearAll()">Clear All</button>
        <br><br>
        <div class="slider-container">
            <label>Gravity: <span id="gravityValue">-9.8</span> m/s¬≤</label>
            <input type="range" id="gravitySlider" min="-20" max="-2" step="0.5" value="-9.8">
        </div>
        <div class="slider-container">
            <label>Bounciness: <span id="bounceValue">0.7</span></label>
            <input type="range" id="bounceSlider" min="0" max="1" step="0.1" value="0.7">
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);

        // Camera setup
        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(15, 10, 15);
        camera.lookAt(0, 0, 0);

        // Renderer setup
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(20, 20, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.left = -20;
        directionalLight.shadow.camera.right = 20;
        directionalLight.shadow.camera.top = 20;
        directionalLight.shadow.camera.bottom = -20;
        scene.add(directionalLight);

        const pointLight = new THREE.PointLight(0x4ecdc4, 0.5);
        pointLight.position.set(-10, 10, -10);
        scene.add(pointLight);

        // Ground
        const groundGeometry = new THREE.BoxGeometry(30, 0.5, 30);
        const groundMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x2d5016,
            roughness: 0.8
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.position.y = -0.25;
        ground.receiveShadow = true;
        scene.add(ground);

        // Walls
        const wallMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x555555,
            roughness: 0.7,
            transparent: true,
            opacity: 0.3
        });

        const wallHeight = 15;
        const wallThickness = 0.5;

        function createWall(width, depth, x, z) {
            const geometry = new THREE.BoxGeometry(width, wallHeight, depth);
            const wall = new THREE.Mesh(geometry, wallMaterial);
            wall.position.set(x, wallHeight/2, z);
            wall.receiveShadow = true;
            return wall;
        }

        scene.add(createWall(30, wallThickness, 0, -15));  // Back
        scene.add(createWall(30, wallThickness, 0, 15));   // Front
        scene.add(createWall(wallThickness, 30, -15, 0));  // Left
        scene.add(createWall(wallThickness, 30, 15, 0));   // Right

        // Physics objects array
        const physicsObjects = [];

        // Physics settings
        let gravity = -9.8;
        let restitution = 0.7;
        const friction = 0.98;
        const airResistance = 0.995;

        // Physics object class
        class PhysicsObject {
            constructor(mesh, mass = 1) {
                this.mesh = mesh;
                this.mass = mass;
                this.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 5,
                    0,
                    (Math.random() - 0.5) * 5
                );
                this.angularVelocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 5,
                    (Math.random() - 0.5) * 5,
                    (Math.random() - 0.5) * 5
                );
                this.radius = this.calculateRadius();
            }

            calculateRadius() {
                const geometry = this.mesh.geometry;
                geometry.computeBoundingSphere();
                return geometry.boundingSphere.radius;
            }

            update(deltaTime) {
                // Apply gravity
                this.velocity.y += gravity * deltaTime;

                // Apply air resistance
                this.velocity.multiplyScalar(airResistance);

                // Update position
                this.mesh.position.add(this.velocity.clone().multiplyScalar(deltaTime));

                // Update rotation
                this.mesh.rotation.x += this.angularVelocity.x * deltaTime;
                this.mesh.rotation.y += this.angularVelocity.y * deltaTime;
                this.mesh.rotation.z += this.angularVelocity.z * deltaTime;

                // Ground collision
                if (this.mesh.position.y - this.radius <= 0) {
                    this.mesh.position.y = this.radius;
                    this.velocity.y = -this.velocity.y * restitution;
                    this.velocity.x *= friction;
                    this.velocity.z *= friction;
                    this.angularVelocity.multiplyScalar(0.95);

                    // Stop if moving very slowly
                    if (Math.abs(this.velocity.y) < 0.1) {
                        this.velocity.y = 0;
                    }
                }

                // Wall collisions
                const bounds = 14.5;

                if (this.mesh.position.x - this.radius < -bounds) {
                    this.mesh.position.x = -bounds + this.radius;
                    this.velocity.x = -this.velocity.x * restitution;
                }
                if (this.mesh.position.x + this.radius > bounds) {
                    this.mesh.position.x = bounds - this.radius;
                    this.velocity.x = -this.velocity.x * restitution;
                }
                if (this.mesh.position.z - this.radius < -bounds) {
                    this.mesh.position.z = -bounds + this.radius;
                    this.velocity.z = -this.velocity.z * restitution;
                }
                if (this.mesh.position.z + this.radius > bounds) {
                    this.mesh.position.z = bounds - this.radius;
                    this.velocity.z = -this.velocity.z * restitution;
                }
            }
        }

        // Spawn functions
        function spawnBall() {
            const colors = [0xff6b6b, 0x4ecdc4, 0xffd700, 0x9b59b6, 0x2ecc71];
            const color = colors[Math.floor(Math.random() * colors.length)];
            
            const geometry = new THREE.SphereGeometry(0.5 + Math.random() * 0.5, 32, 32);
            const material = new THREE.MeshStandardMaterial({ 
                color: color,
                metalness: 0.3,
                roughness: 0.4
            });
            const ball = new THREE.Mesh(geometry, material);
            ball.position.set(
                (Math.random() - 0.5) * 10,
                10 + Math.random() * 5,
                (Math.random() - 0.5) * 10
            );
            ball.castShadow = true;
            scene.add(ball);

            const physicsObj = new PhysicsObject(ball);
            physicsObjects.push(physicsObj);
        }

        function spawnCube() {
            const colors = [0xff6b6b, 0x4ecdc4, 0xffd700, 0x9b59b6, 0x2ecc71];
            const color = colors[Math.floor(Math.random() * colors.length)];
            
            const size = 0.8 + Math.random() * 0.8;
            const geometry = new THREE.BoxGeometry(size, size, size);
            const material = new THREE.MeshStandardMaterial({ 
                color: color,
                metalness: 0.4,
                roughness: 0.5
            });
            const cube = new THREE.Mesh(geometry, material);
            cube.position.set(
                (Math.random() - 0.5) * 10,
                10 + Math.random() * 5,
                (Math.random() - 0.5) * 10
            );
            cube.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );
            cube.castShadow = true;
            scene.add(cube);

            const physicsObj = new PhysicsObject(cube);
            physicsObjects.push(physicsObj);
        }

        function spawnMultiple() {
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    if (Math.random() > 0.5) {
                        spawnBall();
                    } else {
                        spawnCube();
                    }
                }, i * 200);
            }
        }

        function clearAll() {
            physicsObjects.forEach(obj => {
                scene.remove(obj.mesh);
                obj.mesh.geometry.dispose();
                obj.mesh.material.dispose();
            });
            physicsObjects.length = 0;
        }

        // Slider controls
        document.getElementById('gravitySlider').addEventListener('input', (e) => {
            gravity = parseFloat(e.target.value);
            document.getElementById('gravityValue').textContent = gravity.toFixed(1);
        });

        document.getElementById('bounceSlider').addEventListener('input', (e) => {
            restitution = parseFloat(e.target.value);
            document.getElementById('bounceValue').textContent = restitution.toFixed(1);
        });

        // Camera controls
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let cameraDistance = Math.sqrt(
            camera.position.x ** 2 + 
            camera.position.y ** 2 + 
            camera.position.z ** 2
        );
        let cameraAngleX = Math.atan2(camera.position.z, camera.position.x);
        let cameraAngleY = Math.asin(camera.position.y / cameraDistance);
        const lookAtPoint = new THREE.Vector3(0, 3, 0);

        renderer.domElement.addEventListener('mousedown', (e) => {
            if (e.button === 2) {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            }
        });

        renderer.domElement.addEventListener('mouseup', () => {
            isDragging = false;
        });

        renderer.domElement.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;

                cameraAngleX -= deltaX * 0.01;
                cameraAngleY += deltaY * 0.01;
                cameraAngleY = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, cameraAngleY));

                updateCameraPosition();
                previousMousePosition = { x: e.clientX, y: e.clientY };
            }
        });

        renderer.domElement.addEventListener('wheel', (e) => {
            e.preventDefault();
            cameraDistance += e.deltaY * 0.02;
            cameraDistance = Math.max(10, Math.min(40, cameraDistance));
            updateCameraPosition();
        });

        renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());

        function updateCameraPosition() {
            camera.position.x = lookAtPoint.x + cameraDistance * Math.cos(cameraAngleY) * Math.cos(cameraAngleX);
            camera.position.y = lookAtPoint.y + cameraDistance * Math.sin(cameraAngleY);
            camera.position.z = lookAtPoint.z + cameraDistance * Math.cos(cameraAngleY) * Math.sin(cameraAngleX);
            camera.lookAt(lookAtPoint);
        }

        // Animation loop
        let lastTime = performance.now();
        function animate() {
            requestAnimationFrame(animate);

            const currentTime = performance.now();
            const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.02);
            lastTime = currentTime;

            // Update all physics objects
            physicsObjects.forEach(obj => obj.update(deltaTime));

            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Spawn initial objects
        spawnBall();
        spawnBall();
        spawnCube();

        animate();
    </script>
</body>
</html>